<!DOCTYPE html>
<html>
<head>
	<title>test</title>
</head>
<body>
	<canvas id="canvas" width="600" height="600" style="border:1px solid #000000;">
	</canvas>

	<script>
		//
		class NeuralNetwork {
			//
			constructor() {
				// Hyper parameters
				this.inputLayerSize = 2;
				this.hiddenLayerSize = 3;
				this.outputLayerSize = 1;

				// Weights
				this.W1 = this.generateWeightsArray(this.inputLayerSize, this.hiddenLayerSize);
				this.W2 = this.generateWeightsArray(this.hiddenLayerSize, this.outputLayerSize);

				this.z2;
				this.a2;
				this.z3;
				this.yHat;
			}

			/*
			Create a matrix from size (dimensionSize1, dimensionSize2) and put number between 0 and 1 in each cells.
			*/
			generateWeightsArray(dimensionSize1, dimensionSize2) {
				var result = new Array(dimensionSize1);

				for (var i = 0; i < dimensionSize1; i++) {
					result[i] = new Array(dimensionSize2);
				}

				for (var x = 0; x < dimensionSize1; x++) {
					for (var y = 0; y < dimensionSize2; y++) {
						result[x][y] = Math.random() * 2 - 1;
					}
				}

				return result
			}

			// Propagate input through the network
			forward(X) {
				//input to hidden layer
				this.z2 = multiplyMatrix(X, this.W1);

				//activation function
				this.a2 = this.sigmoid(this.z2);

				//hidden to output layer
				this.z3 = multiplyMatrix(this.a2, this.W2);

				//activation function
				this.yHat = this.sigmoid(this.z3);

				return this.yHat;
			}

			// Apply sigmoid function
			sigmoid(matrix) {
				var resultArray = new Array(matrix.length);

				for (var i = 0; i < matrix.length; i++) {
					resultArray[i] = new Array(matrix[0].length);
					for (var j = 0; j < matrix[0].length; j++) {
						// Math.exp -> base of the natural logarithm (2.718)
						resultArray[i][j] = 1/(1+Math.exp(-matrix[i][j]));
					}
				}

			    return resultArray;
			}

			// Apply gradient of Sigmoid
			sigmoidPrime(matrix) {
				var resultArray = new Array(matrix.length);

				for (var i = 0; i < matrix.length; i++) {
					resultArray[i] = new Array(matrix[0].length);
					for (var j = 0; j < matrix[0].length; j++) {
						resultArray[i][j] = Math.exp(-matrix[i][j]) / ((1+Math.exp(-matrix[i][j]))**2);
					}
				}
				
			    return resultArray;
			}

			// Get the difference between the result and the wanted result
			// Allow to know which side the slope is going
			// if - => going down
			// if + => going up
			costFunction(arrayX, arrayY) {
				this.yHat = this.forward(arrayX);

				// 
				var tmp = operationOnMatrix(arrayY, this.yHat, substract);
				tmp = operationOnMatrixValuesByNumber(tmp, 2, power);

				// Add all the tmp array value and divide it by 2
				var J = 0.5 * tmp.reduce((pv, cv) => parseFloat(pv)+parseFloat(cv), 0);

				return J;
			}

			//
			costFunctionPrime(arrayX, arrayY) {
				// Get yHat
				this.yHat = this.forward(arrayX);

				var tmp = operationOnMatrix(arrayY, this.yHat, substract);
				tmp = operationOnMatrixValuesByNumber(tmp, -1, multiply);

				var delta3 = operationOnMatrix(tmp, this.sigmoidPrime(this.z3), multiply);
				var dJdW2 = multiplyMatrix(transposeMatrix(this.a2), delta3)

				var delta2 = multiplyMatrix(multiplyMatrix(delta3, transposeMatrix(this.W2)), this.sigmoidPrime(this.z2));
				var dJdW1 = multiplyMatrix(transposeMatrix(arrayX), delta2);

				return [dJdW1, dJdW2];
			}

			// Get W1 and W2 rolled into a vector
			getParams() {
				var params = new Array();

				params.push(ravel(this.W1));
				params.push(ravel(this.W2));

				return ravel(params);
			}

			// Set W1 and W2 using single parameter vector
			setParams(params) {
				var W1_start = 0;

				var W1_end = this.hiddenLayerSize*this.inputLayerSize;
				this.W1 = reshape(slice(params, W1_start, W1_end), this.inputLayerSize, this.hiddenLayerSize);

				var W2_end = W1_end + this.hiddenLayerSize * this.outputLayerSize
				this.W2 = reshape(slice(params, W1_end, W2_end), this.hiddenLayerSize, this.outputLayerSize);
			}

			computeGradients(arrayX, arrayY) {
				var params = new Array();
				var dJdW = this.costFunctionPrime(arrayX, arrayY);

				params.push(ravel(dJdW[0]));
				params.push(ravel(dJdW[1]));

				return ravel(params);
			}
		}

		//
		function computeNumericalGradient(neural_net, arrayX, arrayY) {
			paramsInitial = neural_net.getParams();
			numgrad = createZerosArray(paramsInitial.length);
			perturb = createZerosArray(paramsInitial.length);
			e = 0.0001;

			//
			for (var i = 0; i < paramsInitial.length; i++) {
				// Set the perturbation
				perturb[i] = e;

				//console.log(neural_net.W1);
				//console.log(neural_net.W2);
				neural_net.setParams(operationOnMatrix(paramsInitial, perturb, add));
				loss2 = neural_net.costFunction(arrayX, arrayY);

				neural_net.setParams(operationOnMatrix(paramsInitial, perturb, substract));
				loss1 = neural_net.costFunction(arrayX, arrayY);

				/*console.log(neural_net.W1);
				console.log(neural_net.W2);

				console.log(loss2);
				console.log(loss1);
				console.log("--------------------");*/

				// Compute the numerical gradient
				numgrad[i] = (loss2 - loss1) / (2*e);
				/*console.log(loss2);
				console.log(loss1);
				console.log(numgrad[i]);
				console.log("--------------------");*/

				// Reset the values we changed
				perturb[i] = 0;
			}

			// Reset the values we changed
			neural_net.setParams(paramsInitial);

			return numgrad
		}

		// Transform a multidimensionnal array into an 1 dimension array
		function ravel(array) {
			var result = new Array();

			for (var i = 0; i < array.length; i++) {
				for (var j = 0; j < array[i].length; j++) {
					result.push(array[i][j]);
				}
			}

			return result;
		}

		// Slice an array
		function slice(array, start, end) {
			var result = new Array();

			for (var i = start; i < end; i++) {
				result.push(array[i]);
			}

			//return array;
			return result;
		}

		// Reshape a multidimensionnal array
		function reshape(array, sizeA, sizeB) {
			var result = new Array();

			// Used to know where we are in the old array
			var firstIndex = 0;
			var secondIndex = 0;

			// Create the new array
			for (var i = 0; i < sizeA; i++) {
				result[i] = new Array();
			}

			// Put the old values in the new array
			for (var i = 0; i < sizeA * sizeB; i++) { //  may be false
				result[firstIndex][secondIndex] = array[i];

				secondIndex++;
				if (secondIndex >= sizeB) {
					secondIndex = 0;
					firstIndex++;
				}
			}

			return result;
		}

		//
		function getMaxValue(array, axis) {
			var myArray = array;
			var maxValue = 0;

			if (typeof array[0][0] != "undefined") {
				for (var i = 0; i < myArray.length; i++) {
					if (myArray[i][axis] > maxValue) {
						maxValue = myArray[i][axis];
					}
				}
			}
			else{
				for (var i = 0; i < myArray.length; i++) {
					if (myArray[i] > maxValue) {
						maxValue = myArray[i];
					}
				}
			}

			return maxValue;
		}

		// Transpose a matrix
		function transposeMatrix(array) {
			var result;

			result = array[0].map(function(col, i) { 
				return array.map(function(row) { 
					return row[i] 
				})
			});

			return result;
		}

		// Multiply two matrix
		function multiplyMatrix(m1, m2) {
		    var result = new Array();

		    for (var i = 0; i < m1.length; i++) {
		        result[i] = [];
		        for (var j = 0; j < m2[0].length; j++) {
		            var sum = 0;
		            for (var k = 0; k < m1[0].length; k++) {
		                sum += m1[i][k] * m2[k][j];
		            }
		            result[i][j] = sum;
		        }
		    }

		    return result;
		}

		// Allow to make opertation on each value of two matrix [Element wise]
		function operationOnMatrix(arrayA, arrayB, operation) {
			var resultArray = new Array(arrayA.length);

			// If 2d array
			if (typeof arrayA[0][0] != "undefined") {
				for (var i = 0; i < arrayA.length; i++) {
					resultArray[i] = new Array();
					for (var j = 0; j < arrayA[0].length; j++) {
						resultArray[i][j] = operation(arrayA[i][j], arrayB[i][j]);
					}
				}
			}
			else { //If 1d array
				for (var i = 0; i < arrayA.length; i++) {
					resultArray[i] = operation(arrayA[i], arrayB[i]);
				}
			}

			return resultArray;
		}

		// Do an operation to each value of a matrix with a number
		function operationOnMatrixValuesByNumber(array, number, operation){
			var result = new Array();

			for (var i = 0; i < array.length; i++) {
				result[i] = new Array()
				for (var j = 0; j < array[0].length; j++) {
					result[i][j] = operation(array[i][j], number);
				}
			}

			return result;
		}

		// Different operation
		function add(a, b) { return a + b; }
		function substract(a, b) { return a - b; }
		function multiply(a, b) { return a * b; }
		function divide(a, b) { return a / b; }
		function power(a, b) { return a ** b; }

		// Create an array filled with zeros
		function createZerosArray(sizeA) {
			var result = new Array();

			for (var i = 0; i < sizeA; i++) {
				result[i] = 0;
			}

			return result;
		}

		// Get the canvas
		var c = document.getElementById("canvas");
		var ctx = c.getContext("2d");

		// Data
		var arrayX = [[3, 5],[5, 1],[10, 2]];
		var arrayY = [[75], [82], [93]];

		// Max value for each of the array
		var maxX = getMaxValue(arrayX, 0);
		var maxY = 100;

		// Scale the value
		for (var i = 0; i < arrayX.length; i++) {
			for (var j = 0; j < arrayX[0].length; j++) {
				arrayX[i][j] = parseFloat(arrayX[i][j] / maxX);
			}
		}

		for (var i = 0; i < arrayY.length; i++) {
			for (var j = 0; j < arrayY[0].length; j++) {
				arrayY[i][j] = parseFloat(arrayY[i][j] / maxY);
			}
		}

		var neural_net = new NeuralNetwork();
		//yHat = neural_net.forward(arrayX);

		//BUG, mauvais rÃ©sultat
		var numgrad = computeNumericalGradient(neural_net, arrayX, arrayY);
		var grad = neural_net.computeGradients(arrayX, arrayY);

		console.log(numgrad);
		console.log(grad);

		//var test = neural_net.forward(arrayX);

		/*var cost1 = neural_net.costFunction(arrayX, arrayY);
		var test2 = neural_net.costFunctionPrime(arrayX,arrayY);

		var scalar = 3;

		var tmp1 = operationOnMatrixValuesByNumber(test2[0], scalar, multiply);
		neural_net.W1 = operationOnMatrix(neural_net.W1, tmp1, add)
		
		var cost2 = neural_net.costFunction(arrayX, arrayY);

		console.log(cost1);
		console.log(cost2);*/

		//console.log(test2);
		//console.log(arrayY);

		//console.log(neural_net.getParams());
	</script>
</body>
</html>